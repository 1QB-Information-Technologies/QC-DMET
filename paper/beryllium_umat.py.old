'''
    QC-DMET: a python implementation of density matrix embedding theory for ab initio quantum chemistry
    Copyright (C) 2015 Sebastian Wouters
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
'''

import sys
sys.path.append('../src')
import localintegrals, dmet, ringhelper
from pyscf import gto, scf, future
from pyscf.future import cc
from pyscf.future.cc import ccsd
import numpy as np

###  Disclaimer: run one of the three cases for root following
casenumber = 3 # 1, 2 or 3

if ( casenumber == 1 ):
    thecases = np.arange( 3.6, 2.88, -0.1 )
if ( casenumber == 2 ):
    thecases = np.arange( 2.4, 2.92, +0.1 )
if ( casenumber == 3 ):
    thecases = np.arange( 2.4, 1.78, -0.1 )
    
print "Bond lengths (Angstrom) =", thecases


def build_molecule( nat, bl, basisset ):

    mol = gto.Mole()
    mol.atom = []
    r = 0.5 * bl / np.sin(np.pi/nat)
    for i in range(nat):
        theta = i * (2*np.pi/nat)
        mol.atom.append(('Be', (r*np.cos(theta), r*np.sin(theta), 0)))
    mol.basis = { 'Be': basisset, }
    mol.build(verbose=0)
    return mol


smallDMguess = None
largeDMguess = None
for bl in thecases:

    nat = 12
    localization_type = 'meta_lowdin'
    #localization_type = 'boys'
    atoms_per_imp = 1 # Impurity size = 1/2/4 Be atoms
    if ( localization_type == 'meta_lowdin' ):
        isTranslationInvariant = True
    else:
        isTranslationInvariant = False # Boys TI is not OK
    method = 'CC'
    
    ##################################################
    # Minao is minimal basis contracted from cc-pVTZ #
    ##################################################
    be_minao = gto.basis.parse('''
Be    S
   6863.0000000              0.0002360        
   1030.0000000              0.0018260        
    234.7000000              0.0094520        
     66.5600000              0.0379570        
     21.6900000              0.1199650        
      7.7340000              0.2821620        
      2.9160000              0.4274040        
      1.1300000              0.2662780        
      0.2577000              0.0181930        
      0.1101000             -0.0072750        
      0.0440900              0.0019030        
Be    S
   6863.0000000             -0.0000430        
   1030.0000000             -0.0003330        
    234.7000000             -0.0017360        
     66.5600000             -0.0070120        
     21.6900000             -0.0231260        
      7.7340000             -0.0581380        
      2.9160000             -0.1145560        
      1.1300000             -0.1359080        
      0.2577000              0.2280260        
      0.1101000              0.5774410        
      0.0440900              0.3178730        
Be    P
      7.4360000              0.0107360        
      1.5770000              0.0628540        
      0.4352000              0.2481800        
      0.1438000              0.5236990        
      0.0499400              0.3534250       
'''
    )
    '''
    ###########################################
    # Build the molecule with the minao basis #
    ###########################################
    smallmol = build_molecule( nat, bl, be_minao )

    smallmf = scf.RHF(smallmol)
    smallmf.verbose = 3
    smallmf.max_cycle = 1000
    smallmf.scf(dm0=smallDMguess)

    smallDMguess = np.dot( np.dot( smallmf.mo_coeff, np.diag( smallmf.mo_occ ) ), smallmf.mo_coeff.T )
    
    ############################################
    # Solve for the DMET correlation potential #
    ############################################
    rotation = np.eye( smallmol.nao_nr(), dtype=float )
    for i in range(nat):
        theta  = i * (2*np.pi/nat)
        offset = 5 * i # 5 basisfunctions in MINAO
        # Order of AO: 2s 1p
        rotation[ offset+2:offset+5, offset+2:offset+5 ] = ringhelper.p_functions( theta )
    assert( np.linalg.norm( np.dot( rotation, rotation.T ) - np.eye( rotation.shape[0] ) ) < 1e-6 )
    smallInts = localintegrals.localintegrals( smallmf, range( smallmol.nao_nr() ), localization_type, rotation )
    if ( localization_type == 'meta_lowdin' ):
        smallInts.TI_OK = True
    smallInts.molden( 'be12-loc-small.molden' )
    print "There are", smallInts.Norbs, "basisfunctions in the minao basis."

    assert ( nat % atoms_per_imp == 0 )
    orbs_per_imp = smallInts.Norbs * atoms_per_imp / nat

    impurityClusters = []
    for cluster in range( nat / atoms_per_imp ):
        impurities = np.zeros( [ smallInts.Norbs ], dtype=int )
        for orb in range( orbs_per_imp ):
            impurities[ orbs_per_imp*cluster + orb ] = 1
        impurityClusters.append( impurities )

    SCmethod = 'LSTSQ'
    doSCF = False
    smallDMET = dmet.dmet( smallInts, impurityClusters, isTranslationInvariant, method, SCmethod, doSCF )
    Energy_small = smallDMET.doselfconsistent()
    '''
    ###########################################
    # Build the molecule with the large basis #
    ###########################################
    largemol = build_molecule( nat, bl, 'cc-pvtz' )
    
    largemf = scf.RHF(largemol)
    largemf.verbose = 3
    largemf.max_cycle = 1000
    largemf.scf(dm0=largeDMguess)
    
    largeDMguess = np.dot( np.dot( largemf.mo_coeff, np.diag( largemf.mo_occ ) ), largemf.mo_coeff.T )

    ####################################################
    # Rotate the correlation potential to larger basis #
    ####################################################
    rotation = np.eye( largemol.nao_nr(), dtype=float )
    for i in range(nat):
        theta  = i * (2*np.pi/nat)
        offset = 30 * i # 30 basisfunctions in cc-pVTZ
        # Order of AO: 4s 3p 2d 1f
        rotation[ offset+4: offset+7,  offset+4 :offset+7  ] = ringhelper.p_functions( theta )
        rotation[ offset+7: offset+10, offset+7 :offset+10 ] = ringhelper.p_functions( theta )
        rotation[ offset+10:offset+13, offset+10:offset+13 ] = ringhelper.p_functions( theta )
        rotation[ offset+13:offset+18, offset+13:offset+18 ] = ringhelper.d_functions( theta )
        rotation[ offset+18:offset+23, offset+18:offset+23 ] = ringhelper.d_functions( theta )
        rotation[ offset+23:offset+30, offset+23:offset+30 ] = ringhelper.f_functions( theta )
    assert( np.linalg.norm( np.dot( rotation, rotation.T ) - np.eye( rotation.shape[0] ) ) < 1e-6 )
    largeInts = localintegrals.localintegrals( largemf, range( largemol.nao_nr() ), localization_type, rotation )
    #largeInts = localintegrals.localintegrals( largemf, range( largemol.nao_nr() ), localization_type )
    if ( localization_type == 'meta_lowdin' ):
        largeInts.TI_OK = True
    largeInts.molden( 'be12-loc-large.molden' )
    exit(123)
    
    umat_minao    = np.dot( np.dot( smallInts.ao2loc, smallDMET.umat ), smallInts.ao2loc.T )
    S_minao_large = gto.mole.intor_cross('cint1e_ovlp_sph', smallmol, largemol)
    umat_large_ao = np.dot( np.dot( S_minao_large.T, umat_minao ), S_minao_large )
    umat_large    = np.dot( np.dot( largeInts.ao2loc.T, umat_large_ao ), largeInts.ao2loc )

    ##########################################################
    # Perform non-self concistent DMET with umat_large fixed #
    ##########################################################
    assert ( nat % atoms_per_imp == 0 )
    orbs_per_imp = largeInts.Norbs * atoms_per_imp / nat

    impurityClusters = []
    for cluster in range( nat / atoms_per_imp ):
        impurities = np.zeros( [ largeInts.Norbs ], dtype=int )
        for orb in range( orbs_per_imp ):
            impurities[ orbs_per_imp*cluster + orb ] = 1
        impurityClusters.append( impurities )

    SCmethod = 'NONE'
    doSCF = False
    largeDMET = dmet.dmet( largeInts, impurityClusters, isTranslationInvariant, method, SCmethod, doSCF )
    largeDMET.umat = np.array( umat_large, copy=True )
    
    print "Orig umat ="
    smallDMET.print_umat()
    print "New umat ="
    largeDMET.print_umat()
    exit(123)
    
    Energy_large = largeDMET.doselfconsistent()
    
    #########
    # Print #
    #########
    print "Bondlength =", bl
    print "    E(small,RHF)  =", smallmf.hf_energy
    print "    E(small,DMET) =", Energy_small
    print "    E(large,RHF)  =", largemf.hf_energy
    print "    E(large,DMET) =", Energy_large

